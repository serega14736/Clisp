# Haskell #
Haskell- стандартизированный чистый функциональный язык программирования общего назначения. Является одним из самых распространённых языков программирования с поддержкой отложенных вычислений. Система типов — полная, сильная, статическая, с автоматическим выводом типов, основанная на системе типов Хиндли — Милнера. Поскольку язык функциональный, то основная управляющая структура — это функция.

# Особенности  Haskell #

## 1) Работа с бесконечными последовательностями ##
А сейчас мы перейдём к вещам, пугающим и шокирующим «императивных» программистов. Хотите верьте, хотите — нет, но в Haskell есть возможность оперировать бесконечными объектами. Можно завести функцию, которая возвращает бесконечную последовательность натуральных чисел или бесконечную последовательность чисел Фибоначчи, или какую-нибудь другую бесконечную последовательность.

Например, следующая конструкция:
``` Haskell
ones = 1 : ones
```

определяет функцию **ones**, которая возвращает бесконечную последовательность единичек. Действительно, если мы начнём раскрывать это рекурсивное определение, то получим такие выражения:
```Haskell
ones = 1 : 1 : ones,
ones = 1 : 1 : 1 : ones,
ones = 1 : 1 : 1 : 1 : ones,
…
```

Это последовательность, которая остаётся равна сама себе после добавления единицы в начало. Неленивые языки, которым не терпитcя сделать сразу то, что от них просят, очень скоро получат ошибку исполнения (например, ошибку переполнение памяти). Ленивый язык Haskell не спешит раскрывать определение, данное ему справа от знака «равно», а раскрывает его по мере необходимости. Такое «равно» называют «ленивым равно», оно по сути означает определение функции, а не операцию присваивания. Есть функциональные языки, в которых есть два типа «равно» — ленивое (определение функции) и неленивое (вычисление выражения справа и присваивание результата переменной, что слева от знака «равно»).

Рассмотрим функцию **numsFrom**, которая получает один аргумент — целое число **n** — и возвращает список всех целых чисел, которые больше либо равны **n**:
```Haskell
numsFrom n = n : numsFrom (n + 1)
```
Используя эту функцию, можно получить бесконечную последовательность квадратов целых чисел:
```Haskell
squares = map (^2) (numsFrom 0)
```
Выражение **(^2)** означает функцию, которая возводит данное число в квадрат.
Получить первые элементы последовательности можно с помощью функции **take**:
```Hskell
take 5 squares => [0, 1, 4, 9, 16].
```
Функцию **take** можно определить рекурсивно:
```Haskell
take :: Integer -> [a] -> [b]
take 1 (x:xs) = [x]
take n (x:xs) = x : take (n - 1) xs
```
А вот простой способ найти первые 5 степеней двойки:
```Haskell
take 5 powers where powers = map (2 ^) [1..] => [2, 4, 8, 16, 32].
```

## 2) Статическая система типов ##
Каждое выражение в Haskell имеет тип, которые устанавливается во время компиляции. Приложение должно сопоставить все типы. Если они не совпадают, то компилятор забракует программу. Типы являются не только формой гарантии, но и языком выражения конструкции программы.

Все переменные в Haskell имеют тип:

```Haskell
char = 'a'    :: Char
int = 123     :: Int
fun = isDigit :: Char -> Bool
```

Вы должны передать функции переменные правильных типов, иначе компилятор отвергнет программу:

```Haskell
Type error
isDigit 1
```

Вы можете декодировать байты в текст:

```Haskell
bytes = Crypto.Hash.SHA1.hash "hello" :: ByteString
text = decodeUtf8 bytes               :: Text
```

Но вы не можете декодировать текст, которые уже является последовательностью символов Unicode:

```Haskell
Type error
doubleDecode = decodeUtf8 (decodeUtf8 bytes)
```

## 3) Логический вывод типов ##
Не обязательно явно назначать тип каждой переменной в Haskell. Типы будут назначены двунаправленной унификацией типов. Однако вы можете обозначить типы, которые выберете, или попросить компилятор обозначит их за вас для легкодоступной документации.

В данном примере для каждой связи есть сигнатура типа:
```Haskell
main :: IO ()
main = do line :: String <- getLine
          print (parseDigit line)
  where parseDigit :: String -> Maybe Int
        parseDigit ((c :: Char) : _) =
          if isDigit c
             then Just (ord c - ord '0')
             else Nothing
```

Но вы можете просто написать следующее:
```Haskell
main = do line <- getLine
          print (parseDigit line)
  where parseDigit (c : _) =
          if isDigit c
             then Just (ord c - ord '0')
             else Nothing
```

Также можно использовать вывод типов во избежание траты времени, объясняя, чего вы хотите:

```Haskell
do ss <- decode "[\"Hello!\",\"World!\"]"
   is <- decode "[1,2,3]"
   return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is)
 => Just ["Hello! 6","World! 7"]
 ```
 
 Типы независимо определяют спецификацию синтаксического анализатора, следующий ввод не приемлем:

```Haskell
do ss <- decode "[1,2,3]"
   is <- decode "[null,null,null]"
   return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is)
 => Nothing
 ```

## 3) Ленивый##
Функции не вычисляют свои аргументы. Это значит, что программа может довольно хорошо сформироваться, с возможностью писать проверяющие конструкции **(н-р if/else)**, просто составляя нормальные функции. Чистота кода Haskell облегчает соединение цепочек из функций, предоставляя преимущество в производительности.

Определить проверяющие конструкции легко:
```Haskell
when p m = if p then m else return ()
main = do args <- getArgs
          when (null args)
               (putStrLn "No args specified!")
```

Если вы заметили повторяющийся паттерн, например такой:
```Haskell
if c then t else False
```

вы можете дать ему имя
```Haskell
and c t = if c then t else False
```

и затем использовать его с тем же успехом, что и первоначальное выражение.

Получите повторное использование кода путем составления ленивых функций. Довольно естественно выразить любую функцию, используя функции **map** или **or**:
```Haskell
any :: (a -> Bool) -> [a] -> Bool
any p = or . map p
```

Использование повторно рекурсивные паттерны в **map, filter, foldr** и других.


