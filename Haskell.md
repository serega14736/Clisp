# Haskell #
Haskell- стандартизированный чистый функциональный язык программирования общего назначения. Является одним из самых распространённых языков программирования с поддержкой отложенных вычислений. Система типов — полная, сильная, статическая, с автоматическим выводом типов, основанная на системе типов Хиндли — Милнера. Поскольку язык функциональный, то основная управляющая структура — это функция.

# Особенности  Haskell #

## 1) Статическая система типов ##
Каждое выражение в Haskell имеет тип, которые устанавливается во время компиляции. Приложение должно сопоставить все типы. Если они не совпадают, то компилятор забракует программу. Типы являются не только формой гарантии, но и языком выражения конструкции программы.

Все переменные в Haskell имеют тип:

```Haskell
char = 'a'    :: Char
int = 123     :: Int
fun = isDigit :: Char -> Bool
```

Вы должны передать функции переменные правильных типов, иначе компилятор отвергнет программу:

```Haskell
Type error
isDigit 1
```

Вы можете декодировать байты в текст:

```Haskell
bytes = Crypto.Hash.SHA1.hash "hello" :: ByteString
text = decodeUtf8 bytes               :: Text
```

Но вы не можете декодировать текст, которые уже является последовательностью символов Unicode:

```Haskell
Type error
doubleDecode = decodeUtf8 (decodeUtf8 bytes)
```

## 2) Логический вывод типов ##
Не обязательно явно назначать тип каждой переменной в Haskell. Типы будут назначены двунаправленной унификацией типов. Однако вы можете обозначить типы, которые выберете, или попросить компилятор обозначит их за вас для легкодоступной документации.

В данном примере для каждой связи есть сигнатура типа:
```Haskell
main :: IO ()
main = do line :: String <- getLine
          print (parseDigit line)
  where parseDigit :: String -> Maybe Int
        parseDigit ((c :: Char) : _) =
          if isDigit c
             then Just (ord c - ord '0')
             else Nothing
```

Но вы можете просто написать следующее:
```Haskell
main = do line <- getLine
          print (parseDigit line)
  where parseDigit (c : _) =
          if isDigit c
             then Just (ord c - ord '0')
             else Nothing
```

Также можно использовать вывод типов во избежание траты времени, объясняя, чего вы хотите:

```Haskell
do ss <- decode "[\"Hello!\",\"World!\"]"
   is <- decode "[1,2,3]"
   return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is)
 => Just ["Hello! 6","World! 7"]
 ```
 
 Типы независимо определяют спецификацию синтаксического анализатора, следующий ввод не приемлем:

```Haskell
do ss <- decode "[1,2,3]"
   is <- decode "[null,null,null]"
   return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is)
 => Nothing
 ```

## 3) Ленивый ##
Функции не вычисляют свои аргументы. Это значит, что программа может довольно хорошо сформироваться, с возможностью писать проверяющие конструкции **(н-р if/else)**, просто составляя нормальные функции. Чистота кода Haskell облегчает соединение цепочек из функций, предоставляя преимущество в производительности.

Определить проверяющие конструкции легко:
```Haskell
when p m = if p then m else return ()
main = do args <- getArgs
          when (null args)
               (putStrLn "No args specified!")
```

Если вы заметили повторяющийся паттерн, например такой:
```Haskell
if c then t else False
```

вы можете дать ему имя
```Haskell
and c t = if c then t else False
```

и затем использовать его с тем же успехом, что и первоначальное выражение.

Получите повторное использование кода путем составления ленивых функций. Довольно естественно выразить любую функцию, используя функции **map** или **or**:
```Haskell
any :: (a -> Bool) -> [a] -> Bool
any p = or . map p
```

Использование повторно рекурсивные паттерны в **map, filter, foldr** и других.

## 4) Чисто функциональный ##
Каждая функция в Haskell это функция в математическом смысле (т.е. "чистая"). Даже операции ввода/вывода, влекущие за собой некоторые побочные эффекты и являющиеся только описанием действия, написаны на чистом коде. Здесь нет утверждений и инструкций, только выражения, которые не могут видоизмениться в переменные (локальные или глобальные) и которые не имеют доступ к структурам таким как время или случайные числа.

Следующая функция принимает целое число и возвращает целое число. Из-за типа она не может произвести побочного эффекта во что бы то ни было, она не может изменить ни один из своих аргументов.
```Haskell
square :: Int -> Int
square x = x * x
```

Следующее соединение строк будет произведено успешно:
```Haskell
"Hello: " ++ "World!"
```

Однако следующий пример выдаст ошибку типов:

```Haskell
Type error
"Name: " ++ getLine
```
так как **getLine** имеет тип **IO String**, а не **String** как "Name: ". Поэтому из-за системы типов вы не можете смешивать и соотносить чистое и нечистое.

## 5) Параллельность ##

Haskell хорошо сочетается с параллельным программированием из-за явной обработки эффектов. В его ведущем компиляторе, GHC, присутствует высоко производительный параллельный сборщик мусора и легковесная библиотека распараллеливания, содержащая полезные примитивы распараллеливания и абстракции.

Легко установите потоки и связывайтесь со стандартной библиотекой:

```Haskell
main = do
  done <- newEmptyMVar
  forkIO (do putStrLn "I'm one thread!"
             putMVar done "Done!")
  second <- forkIO (do delayThread 100000
                       putStrLn "I'm another thread!")
  killThread second
  msg <- takeMVar done
  putStrLn msg
```

Используйте асинхронный **API** для потоков:
```Haskell
do a1 <- async (getURL url1)
  a2 <- async (getURL url2)
  page1 <- wait a1
  page2 <- wait a2
  ...
```
Атомарные потоки с программной транзакционной памятью:

```Haskell
transfer :: Account -> Account -> Int -> IO ()
transfer from to amount =
  atomically (do deposit to amount
                 withdraw from amount)
```

Атомарные транзакции должны быть повторяющимися, поэтому независимый ввод/вывод запрещен в системе типов:
```Haskell
Type error
main = atomically (putStrLn "Hello!")
```

# Области применения Haskell #
Распространенное заблуждение в отношении Haskell заключается в том, что этот язык якобы пригоден для решения только узкого круга хитроумных математических задач. И действительно, как прикажете решать «обычные» задачи, если у нас даже циклов нет? На самом деле, рекурсия ничем не хуже циклов. Думать итерациями или думать рекурсиями — это всего лишь дело привычки. И нет, рекурсия совсем не обязательно должна использовать какую-то память. Вообще-то, именно злоупотребление ООП в конечном счете приводит к мышлению по шаблону, и выводам в стиле «видимо, эта задачка с олимпиады по спортивному программированию, раз я не знаю, как ее решить».

Если вы предпочитаете работать с фреймворками, то будете рады узнать, что для Haskell написано довольно много готовых веб-фрейморков.

Haskell прекрасно подходит для работы с сетью, базами данных, регулярными выражениями, написания компиляторов и многого другого. Код на Haskell может взаимодействовать с кодом на других языках и быть скомпилирован в байткод LLVM, JVM и .NET, а также в JavaScript. На Haskell можно писать даже модули ядра Linux.

Среди интересных проектов на Haskell мне хотелось бы отметить фреймовый оконный менеджер Xmonad, интерактивную среду разработки Leksah, текстовый редактор Yi, генератор статических сайтов Hakyll, torrent-клиент СombinaTorrent, веб-браузер Hbro, распределенную систему управления версиями Darcs, компилятор языка программирования Perl 6 под названием Pugs, шутер от первого лица Frag, движок рендеринга трехмерной графики Lambda Cube 3D, игровой движок HGamer3D и  операционную систему House.
# Преимущества и недостатки #

## Преимущества ##
1) Красота и декларативность языка
2) Автоматическое управление памятью
3) Чистые функции
4) Быстродействие
5) Меньше рефакторинга
6) Широкая область применения

## Недостатки ##
1) Хорошие учебники начального уровня немногочисленны и их трудно найти, поэтому начальная кривая обучения довольно крутая.
2) По умолчанию Haskell лениво оценивается, и, хотя это часто бывает здорово, иногда он может вас укусить. Наивное использование ленивых вычислений в нетривиальных ситуациях может привести к ненужным узким местам производительности, и понимание того, что происходит под капотом, не совсем просто.
3) Из-за чистоты Haskell вы не можете использовать побочные эффекты для таких вещей, как ввод / вывод; Вы должны использовать монаду и ленивую оценку «злоупотреблять» для достижения интерактивности, и вы должны перетаскивать монадический контекст куда угодно, где вы захотите выполнить ввод / вывод. 

# Начало работы с Haskell #
Мы не можем начать изучение языка без испытательного полигона. Установим Haskell.

Сделать это можно несколькими способами, мы выберем самый удобный. Называется он [The Haskell Tool Stack](https://docs.haskellstack.org/en/stable/README). Эта маленькая утилита — всё, что вам понадобится для работы с Haskell.

Haskell — кроссплатформенный язык, работающий и в Linux, и в macOS OS X, и даже в Windows. Однако в 2008 году я навсегда покинул мир Windows, поэтому все последующие примеры взаимодействия с командной строкой подразумевают Unix-way. Впрочем, если вы всё-таки используете Windows, будьте уверены — всё описанное ниже заработает и у вас.

### Устанавливаем ###

Заходим [сюда](https://docs.haskellstack.org/en/stable/install_and_upgrade/) и забираем нужную нам версию. Общий Unix-вариант установки предельно прост:
```Haskell
$ curl -sSL https://get.haskellstack.org/ | sh
```
