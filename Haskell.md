# Haskell #
Haskell - стандартизированный чистый функциональный язык программирования общего назначения. Является одним из самых распространённых языков программирования с поддержкой отложенных вычислений. Система типов — полная, сильная, статическая, с автоматическим выводом типов, основанная на системе типов Хиндли — Милнера. Поскольку язык функциональный, то основная управляющая структура — это функция.

# Особенности  Haskell #

## 1) Статическая система типов ##
Каждое выражение в Haskell имеет тип, которые устанавливается во время компиляции. Приложение должно сопоставить все типы. Если они не совпадают, то компилятор забракует программу. Типы являются не только формой гарантии, но и языком выражения конструкции программы.

Все переменные в Haskell имеют тип:

```Haskell
char = 'a'    :: Char
int = 123     :: Int
fun = isDigit :: Char -> Bool
```

Вы должны передать функции переменные правильных типов, иначе компилятор отвергнет программу:

```Haskell
Type error
isDigit 1
```

Вы можете декодировать байты в текст:

```Haskell
bytes = Crypto.Hash.SHA1.hash "hello" :: ByteString
text = decodeUtf8 bytes               :: Text
```

Но вы не можете декодировать текст, которые уже является последовательностью символов Unicode:

```Haskell
Type error
doubleDecode = decodeUtf8 (decodeUtf8 bytes)
```

## 2) Логический вывод типов ##
Не обязательно явно назначать тип каждой переменной в Haskell. Типы будут назначены двунаправленной унификацией типов. Однако вы можете обозначить типы, которые выберете, или попросить компилятор обозначит их за вас для легкодоступной документации.

В данном примере для каждой связи есть сигнатура типа:
```Haskell
main :: IO ()
main = do line :: String <- getLine
          print (parseDigit line)
  where parseDigit :: String -> Maybe Int
        parseDigit ((c :: Char) : _) =
          if isDigit c
             then Just (ord c - ord '0')
             else Nothing
```

Но вы можете просто написать следующее:
```Haskell
main = do line <- getLine
          print (parseDigit line)
  where parseDigit (c : _) =
          if isDigit c
             then Just (ord c - ord '0')
             else Nothing
```

Также можно использовать вывод типов во избежание траты времени, объясняя, чего вы хотите:

```Haskell
do ss <- decode "[\"Hello!\",\"World!\"]"
   is <- decode "[1,2,3]"
   return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is)
 => Just ["Hello! 6","World! 7"]
 ```
 
 Типы независимо определяют спецификацию синтаксического анализатора, следующий ввод не приемлем:

```Haskell
do ss <- decode "[1,2,3]"
   is <- decode "[null,null,null]"
   return (zipWith (\s i -> s ++ " " ++ show (i + 5)) ss is)
 => Nothing
 ```

## 3) Ленивый ##
Функции не вычисляют свои аргументы. Это значит, что программа может довольно хорошо сформироваться, с возможностью писать проверяющие конструкции **(н-р if/else)**, просто составляя нормальные функции. Чистота кода Haskell облегчает соединение цепочек из функций, предоставляя преимущество в производительности.

Определить проверяющие конструкции легко:
```Haskell
when p m = if p then m else return ()
main = do args <- getArgs
          when (null args)
               (putStrLn "No args specified!")
```

Если вы заметили повторяющийся паттерн, например такой:
```Haskell
if c then t else False
```

вы можете дать ему имя
```Haskell
and c t = if c then t else False
```

и затем использовать его с тем же успехом, что и первоначальное выражение.

Получите повторное использование кода путем составления ленивых функций. Довольно естественно выразить любую функцию, используя функции **map** или **or**:
```Haskell
any :: (a -> Bool) -> [a] -> Bool
any p = or . map p
```

Использование повторно рекурсивные паттерны в **map, filter, foldr** и других.

## 4) Чисто функциональный ##
Каждая функция в Haskell это функция в математическом смысле (т.е. "чистая"). Даже операции ввода/вывода, влекущие за собой некоторые побочные эффекты и являющиеся только описанием действия, написаны на чистом коде. Здесь нет утверждений и инструкций, только выражения, которые не могут видоизмениться в переменные (локальные или глобальные) и которые не имеют доступ к структурам таким как время или случайные числа.

Следующая функция принимает целое число и возвращает целое число. Из-за типа она не может произвести побочного эффекта во что бы то ни было, она не может изменить ни один из своих аргументов.
```Haskell
square :: Int -> Int
square x = x * x
```

Следующее соединение строк будет произведено успешно:
```Haskell
"Hello: " ++ "World!"
```

Однако следующий пример выдаст ошибку типов:

```Haskell
Type error
"Name: " ++ getLine
```
так как **getLine** имеет тип **IO String**, а не **String** как "Name: ". Поэтому из-за системы типов вы не можете смешивать и соотносить чистое и нечистое.

## 5) Параллельность ##

Haskell хорошо сочетается с параллельным программированием из-за явной обработки эффектов. В его ведущем компиляторе, GHC, присутствует высоко производительный параллельный сборщик мусора и легковесная библиотека распараллеливания, содержащая полезные примитивы распараллеливания и абстракции.

Легко установите потоки и связывайтесь со стандартной библиотекой:

```Haskell
main = do
  done <- newEmptyMVar
  forkIO (do putStrLn "I'm one thread!"
             putMVar done "Done!")
  second <- forkIO (do delayThread 100000
                       putStrLn "I'm another thread!")
  killThread second
  msg <- takeMVar done
  putStrLn msg
```

Используйте асинхронный **API** для потоков:
```Haskell
do a1 <- async (getURL url1)
  a2 <- async (getURL url2)
  page1 <- wait a1
  page2 <- wait a2
  ...
```
Атомарные потоки с программной транзакционной памятью:

```Haskell
transfer :: Account -> Account -> Int -> IO ()
transfer from to amount =
  atomically (do deposit to amount
                 withdraw from amount)
```

Атомарные транзакции должны быть повторяющимися, поэтому независимый ввод/вывод запрещен в системе типов:
```Haskell
Type error
main = atomically (putStrLn "Hello!")
```

# Области применения Haskell #
Распространенное заблуждение в отношении Haskell заключается в том, что этот язык якобы пригоден для решения только узкого круга хитроумных математических задач. И действительно, как прикажете решать «обычные» задачи, если у нас даже циклов нет? На самом деле, рекурсия ничем не хуже циклов. Думать итерациями или думать рекурсиями — это всего лишь дело привычки. И нет, рекурсия совсем не обязательно должна использовать какую-то память. Вообще-то, именно злоупотребление ООП в конечном счете приводит к мышлению по шаблону, и выводам в стиле «видимо, эта задачка с олимпиады по спортивному программированию, раз я не знаю, как ее решить».

Если вы предпочитаете работать с фреймворками, то будете рады узнать, что для Haskell написано довольно много готовых веб-фрейморков.

Haskell прекрасно подходит для работы с сетью, базами данных, регулярными выражениями, написания компиляторов и многого другого. Код на Haskell может взаимодействовать с кодом на других языках и быть скомпилирован в байткод LLVM, JVM и .NET, а также в JavaScript. На Haskell можно писать даже модули ядра Linux.

Среди интересных проектов на Haskell мне хотелось бы отметить фреймовый оконный менеджер Xmonad, интерактивную среду разработки Leksah, текстовый редактор Yi, генератор статических сайтов Hakyll, torrent-клиент СombinaTorrent, веб-браузер Hbro, распределенную систему управления версиями Darcs, компилятор языка программирования Perl 6 под названием Pugs, шутер от первого лица Frag, движок рендеринга трехмерной графики Lambda Cube 3D, игровой движок HGamer3D и  операционную систему House.
# Преимущества и недостатки #

## Преимущества ##
1) Красота и декларативность языка
2) Автоматическое управление памятью
3) Чистые функции
4) Быстродействие
5) Меньше рефакторинга
6) Широкая область применения

## Недостатки ##
1) Хорошие учебники начального уровня немногочисленны и их трудно найти, поэтому начальная кривая обучения довольно крутая.
2) По умолчанию Haskell лениво оценивается, и, хотя это часто бывает здорово, иногда он может вас укусить. Наивное использование ленивых вычислений в нетривиальных ситуациях может привести к ненужным узким местам производительности, и понимание того, что происходит под капотом, не совсем просто.
3) Из-за чистоты Haskell вы не можете использовать побочные эффекты для таких вещей, как ввод / вывод; Вы должны использовать монаду и ленивую оценку «злоупотреблять» для достижения интерактивности, и вы должны перетаскивать монадический контекст куда угодно, где вы захотите выполнить ввод / вывод. 

# Начало работы с Haskell #
Мы не можем начать изучение языка без испытательного полигона. Установим Haskell.

Сделать это можно несколькими способами, мы выберем самый удобный. Называется он [The Haskell Tool Stack](https://docs.haskellstack.org/en/stable/README). Эта маленькая утилита — всё, что вам понадобится для работы с Haskell.

Haskell — кроссплатформенный язык, работающий и в Linux, и в macOS OS X, и даже в Windows. Однако в 2008 году я навсегда покинул мир Windows, поэтому все последующие примеры взаимодействия с командной строкой подразумевают Unix-way. Впрочем, если вы всё-таки используете Windows, будьте уверены — всё описанное ниже заработает и у вас.

### Устанавливаем ###

Заходим [сюда](https://docs.haskellstack.org/en/stable/install_and_upgrade/) и забираем нужную нам версию. Общий Unix-вариант установки предельно прост:
```Haskell
$ curl -sSL https://get.haskellstack.org/ | sh
```

Готово. После установки нам будет доступна команда **stack**, и она — наше всё.

На момент написания книги я использовал **stack** версии 1.4.0. Если у вас более старая версия — непременно обновитесь. Если же более новая — у вас что-нибудь может работать не совсем так, как описано ниже, поскольку **stack** всё ещё активно развивается.

Главное (но не единственное), что умеет делать **stack**, это:

1)Разворачивать инфраструктуру.
2)Собирать проекты.
3)Устанавливать библиотеки.

Haskell-инфраструктура — экосистема, краеугольным камнем которой является ранее упомянутый компилятор GHC. Haskell является компилируемым языком: приложение представляет собой обыкновенный исполняемый (англ. executable) файл.

Haskell-проект — среда для создания приложений и библиотек.

Haskell-библиотеки — кем-то написанные решения, спасающие нас от изобретения велосипедов.

### Разворачиваем инфраструктуру ###
Делаем:
```Haskell
$ stack setup
```

В результате на ваш компьютер будет установлена инфраструктура последней стабильной версии. Жить всё это хозяйство будет в только что созданном каталоге **~/.stack/**. Именно поэтому устанавливать инфраструктуру для последующих Haskell-проектов вам уже не придётся: единожды развернули, используем всегда. Пока вам не нужно знать об устройстве этой инфраструктуры, воспринимайте её как данность: теперь на вашем компьютере живёт Haskell.

### Hi World ###
Создадим наш первый Haskell-проект:
```Haskell
$ stack new real
```

Здесь **real** — название проекта. В результате будет создан каталог real, внутри которого мы увидим это:
```Haskell
.
├── app
│   └── Main.hs <- Главный модуль программы
├── LICENSE
├── README.md
├── real.cabal  <- Сборочный конфиг проекта
├── Setup.hs
├── src
│   └── Lib.hs  <- Ещё один модуль
├── stack.yaml  <- Конфиг Stack
└── test
    └── Spec.hs <- Тесты, они нам пока не нужны
```

Теперь переходим в каталог **real** и собираем проект командой:

```Haskell
$ stack build
```

Запомните эту команду, мы будем использовать её постоянно. В результате сборки появится файл **real-exe**. Располагается он внутри скрытого каталога **.stack-work** в корне проекта. Чтобы сразу его запустить, не копаясь во внутренностях этого скрытого каталога, используем команду:

```Haskell
$ stack exec real-exe
someFunc
```

Команда **stack exec** запускает программу (в данном случае **real-exe**) внутри **stack**-окружения. Впрочем, мы можем запустить нашу программу и напрямую, без **stack**. Исполняемый файл **real-exe** находится внутри скрытого каталога **.stack-work** в корне проекта. Например, на моём компьютере путь к исполняемому файлу такой:
```Haskell
.stack-work/dist/x86_64-linux/Cabal-1.24.2.0/build/real-exe/real-exe
```

Но можно и упростить себе жизнь, выполнив команду:
```Haskell
$ stack install
```

В результате исполняемый файл будет скопирован в каталог **~/.local/bin** (подразумевается, что такой каталог у вас уже имеется). Кстати, полезно добавить **~/.local/bin** в **PATH**, что позволит вам тут же запускать программу:
```Haskell
$ real-exe
someFunc
```

Вот мы и создали Haskell-проект и запустили нашу первую программу, выведшую строку **someFunc**. Но как же это работает? Пришла пора познакомиться с фундаментальной единицей проекта — модулем.

### Модули: знакомство ###
Haskell-проект состоит из модулей. Модулем называется файл, содержащий исходный Haskell-код. Один файл — один модуль. Расширение **.hs** — стандартное расширения для модулей. В Haskell нет понятия «заголовочный файл»: каждый из модулей рассматривается как самостоятельная единица проекта, содержащая в себе разные полезные вещи. А чтобы воспользоваться этими вещами, необходимо один модуль импортировать в другой.

Откроем модуль **src/Lib.hs**:
```Haskell
module Lib      -- Имя модуля
    ( someFunc  -- Интерфейс модуля
    ) where

-- Всё содержимое модуля - эта функция.
someFunc :: IO ()
someFunc = putStrLn "someFunc"
```

В первой строке объявлено, что имя этого модуля — **Lib**. Далее в круглых скобках указан интерфейс данного модуля, то есть та его часть, которая видна всему миру. В данном случае это единственная функция **someFunc**, объявление и определение которой идёт далее, вслед за ключевым словом **where**. Пока вам не нужно знать о синтаксисе объявления и определений функции, в следующих главах мы разберём его тщательнейшим образом.

Теперь откроем модуль **app/Main.hs**:

```Haskell
module Main where

import Lib      -- Импортируем модуль Lib...

main :: IO ()
main = someFunc -- Используем его содержимое...
```

Это модуль **Main**, главный модуль нашего приложения, ведь именно здесь определена функция **main**. С помощью директивы **import** мы включаем сюда модуль **Lib** и можем работать с содержимым этого модуля.

Запомните модуль **Main**, с ним мы будем работать чаще всего. Все примеры исходного кода, которые вы увидите на страницах этой книги, живут именно в модуле **Main**, если не оговорено иное.

Все модули в наших проектах можно разделить на две части: те, которые мы берём из библиотек и те, которые мы создали сами. Библиотеки — это уже кем-то написанные решения, в последующих главах мы познакомимся со многими из них. Среди библиотек следует выделить одну, так называемую стандартную библиотеку. Модули из стандартной библиотеки мы начнём использовать уже в ближайших главах. А одна из глав будет полностью посвящена рассказу о библиотеках: из неё мы подробно узнаем, откуда берутся библиотеки и как их можно использовать.

### Для любопытных ###
 До появления **stack** основным способом установки Haskell была так называемая [Haskell Platform](https://www.haskell.org/platform/). Однако именно **stack**, несмотря на свою молодость (вышел в свет летом 2015 года), является предпочтительным путём в мир Haskell, особенно для новичков. Его настолько полюбили, что последние версии Haskell Platform включают в себя **stack** по умолчанию!
 
 Как вы заметили, имена файлов с исходным кодом начинаются с большой буквы: **app/Main.hs** и **src/Lib.hs**. Строго говоря, это необязательно, можно и с маленькой буквы, однако для гармонии с именем модуля лучше придерживаться общепринятой практики и называть файл модуля по имени самого модуля:
 ```Haskell
 app/Main.hs -> module Main ...
src/Lib.hs  -> module Lib ...
```

И ещё. При создании проекта мы могли бы использовать схему **simple** вместо предлагаемой по умолчанию. Для этого проект нужно было создать командой:
```Haskell
$ stack new real simple
```

где **simple** — имя схемы проекта. Дело в том, что команда **stack new** может создавать заготовки проектов для разных нужд. Простейшая из заготовок называется **simple**. В этом случае в проекте отсутствует модуль **src/Lib.hs**, а есть лишь **src/Main.hs**:
```Haskell
.
├── LICENSE
├── Setup.hs
├── real.cabal
├── src
│   └── Main.hs <- Единственный модуль
└── stack.yaml
```
Да, мы могли бы воспользоваться данной схемой, однако в этом случае мы не увидели бы механизма импорта одного модуля в другой. 

### Пример ###
Итак, давайте начнем с привычного “Hello World”.
```Haskell
main = putStrLn "Hello World!"
```

тобы запустить его, сохраните этот код как **hello.hs** и выполните:

```Haskell
 ~ runhaskell ./hello.hs
Hello World!
```

Вы можете скачать исходник по ссылке, которая находится под «Введением»

Сохраняем файл **00_hello_world.lhs** и выполняем:

```Haskell
~ runhaskell 00_hello_world.lhs
Hello World!
```


# Литература #
[Оффициальный сайт](https://www.haskell.org/)
